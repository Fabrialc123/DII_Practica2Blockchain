// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyNFT is ERC721, Ownable {
    uint256 private tokenIdCounter;
    mapping(uint256 => string) private tokenURIs;
    mapping(uint256 => uint256) private tokenPrices;
    mapping(uint256 => bool) private tokensForSale;

    event TokenListedForSale(uint256 indexed tokenId, uint256 price);
    event TokensPurchased(address indexed buyer, uint256 indexed tokenId);

    constructor(string memory _name, string memory _symbol) 
        ERC721(_name, _symbol)
        Ownable(msg.sender) { // Pasando msg.sender como propietario inicial
        tokenIdCounter = 0;
    }

    function mint(string memory _tokenURI) external onlyOwner {
        uint256 newTokenId = tokenIdCounter;
        tokenIdCounter++;

        _mint(msg.sender, newTokenId); // AcuÃ±a el token para el propietario del contrato
        _setTokenURI(newTokenId, _tokenURI);
    }
    
    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal {
        require(_exists(tokenId), "ERC721Metadata: URI set of nonexistent token");
        tokenURIs[tokenId] = _tokenURI;
    }

    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "Token does not exist");
        return tokenURIs[tokenId];
    }

    function setTokenPrice(uint256 tokenId, uint256 price) public onlyOwner {
        tokenPrices[tokenId] = price;
    }

    function listTokenForSale(uint256 tokenId, uint256 price) public {
        require(ownerOf(tokenId) == msg.sender, "You can only list your own tokens for sale");
        require(price > 0, "Price must be greater than 0");

        tokenPrices[tokenId] = price;
        tokensForSale[tokenId] = true;

        emit TokenListedForSale(tokenId, price);
    }

    function purchaseToken(uint256 tokenId) external payable {
        require(_exists(tokenId), "Invalid tokenId");
        require(tokensForSale[tokenId], "Token is not available for purchase");
        require(tokenPrices[tokenId] <= msg.value, "Insufficient ETH sent");

    address previousOwner = ownerOf(tokenId);
    _transfer(previousOwner, msg.sender, tokenId);
    tokensForSale[tokenId] = false;

    // Pagamos al propietario anterior del NFT
    payable(previousOwner).transfer(msg.value);

    emit TokensPurchased(msg.sender, tokenId);
}

function _exists(uint256 tokenId) internal view returns (bool) {
    try this.ownerOf(tokenId) returns (address) {
        return true;
    } catch {
        return false;
    }
}

}
